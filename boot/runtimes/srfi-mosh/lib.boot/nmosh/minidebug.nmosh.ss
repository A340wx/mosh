(library (nmosh minidebug)
	 (export minidebug)
	 (import (rnrs) (nmosh condition-printer) (nmosh conditions)
		 (primitives dbg-files fasl-read))

(define libsyms '())

(define (list-dbgfile)
  (map cadr dbg-files))

(define (get-symfile fn)
  (call-with-port (open-file-input-port fn) fasl-read))

(define (load-symfiles)
  (define syms '())
  (define (addsym l)
    (set! syms (append syms l)))
  (define (step fn)
    (with-condition-printer
      (let ((r (get-symfile fn)))
	(for-each 
	  (lambda (e)
	    (if (eq? 'DBG-SYMS (car e))
	      (addsym (cdr e))))
	  r))))
  (let ((f (list-dbgfile)))
    (for-each step f))
  syms)

(define (fallback-trace-printer p trace)
  (define (cprocprint h)
    (let ((proc (car h)))
      (display "  cprc   " p)
      (display proc p)))
  (define (undec proc)
    (define (chopseqnum l) ; => symbol
      (define (step e cur)
	(if (char=? #\~ e)
	  '()
	  (cons e cur)))
      (string->symbol (list->string (fold-right step '() l))))
    (define (ungensym sym)
      (let ((l (string->list (symbol->string sym))))
	(if (char=? #\& (car l))
	  (chopseqnum (cdr l))
	  sym)))
    (define (do-undec sym)
      (if (symbol? sym)
	(ungensym sym)
	sym))
    (display (map do-undec proc) p))
  (define (decprint proc)
    (define (step cur e)
      (let ((r (assq e libsyms)))
	(if r r cur)))
    (let ((dbg (fold-left step #f proc)))
      (cond
	(dbg
	  (display "==USRP== " p)
	  (undec proc)
	  (display " @ " p)
	  (display (debug-format (cdr dbg)) p))
	(else
	  (display "  usrp   " p)
	  (undec proc)))))
  (define (procprint h)
    (let ((proc (car h))
	  (loc (cadr h)))
      (cond
	(loc
	  (display "  mosh   " p)
	  (display proc p)
	  (display " @ " p)
	  (display (debug-format loc) p))
	(else
	  (decprint proc)))))

  (define (numprint i)
    (when (< i 10)
      (display " " p))
    (when (< i 100)
      (display " " p))
    (display i p)
    (display " : "))

  (define (print num e)
    (let ((id (cadr e))
	  (param (cddr e)))
      (case id
	((*proc*) 
	 (numprint num)
	 (procprint param))
	((*cproc*) 
	 (numprint num)
	 (cprocprint param))
	(else 'ok)))
    (newline p))
  (define (printer t)
    (define (itr i cur)
      (when (pair? cur)
	(case (cadar cur)
	  ((*unknown-proc*)
	   (itr i (cdr cur)))
	  (else
	    (print i (car cur))
	    (itr (+ i 1) (cdr cur))))))
    (itr 1 t))

  (display "TRACE :\n" p)
  (printer (reverse trace)))

(define (minidebug p c trace)
  (set! libsyms (load-symfiles))
  (condition-printer c p)
  (fallback-trace-printer p trace)
  (exit -1))
)
