(import (rnrs) (rnrs eval) (only (psyntax system $all) interaction-environment) (srfi :26) (srfi :8) (mosh))

(define-syntax let1
  (syntax-rules ()
		((_ var val body ...)
		 (let ((var val)) body ...))))

(define (proc-name->c-proc-name name)
  (cond
   [(string=? name "+")
    "addEx"]
   [(string=? name "-")
    "subEx"]
   [(string=? name "*")
    "mulEx"]
   [(string=? name "/")
    "divideEx"]
   [(string=? name "=")
    "eqEx"]
   [(string=? name ">")
    "gtEx"]
   [(string=? name "<")
    "ltEx"]
   [(string=? name ">=")
    "geEx"]
   [(string=? name "<=")
    "leEx"]
   [(string=? name "div")
    "integerDivEx"]
   [(string=? name "div0")
    "integerDiv0Ex"]
   [(string=? name "fldiv")
    "flIntegerDivEx"]
   [(string=? name "flmod")
    "flIntegerModEx"]
   [(string=? name "fldiv0")
    "flIntegerDiv0Ex"]
   [(string=? name "flmod0")
    "flIntegerMod0Ex"]
   [else
    (call-with-string-io
     name
     (lambda (in out)
       (define (rec c)
         (cond
          [(eof-object? c)
           (display "Ex" out)]
          [else
           (case c
             [(#\?)
              (display "P" out)
              (rec (read-char in))]
             [(#\!)
              (display "D" out)
              (rec (read-char in))]
             [(#\%)
              (display "internal" out)
              (display (char-upcase (read-char in)) out)
              (rec (read-char in))]
             [(#\$)
              (rec (read-char in))]
             [(#\>)
              (let1 c (read-char in)
                (cond
                 [(eof-object? c)
                  (display "GtEx" out)]
                 [(char=? #\= c)
                  (display "Ge" out)
                  (rec (read-char in))]
                 [else
                  (display "Gt" out)
                  (rec c)]))]
             [(#\<)
              (let1 c (read-char in)
                (cond
                 [(eof-object? c)
                  (display "LtEx" out)]
                 [(char=? #\= c)
                  (display "Le" out)
                  (rec (read-char in))]
                 [else
                  (display "Lt" out)
                  (rec c)]))]
             [(#\!)
              (rec (read-char in))]
             [(#\=)
              (display "Eq" out)
              (rec (read-char in))]
             [(#\+)
              (display "Add" out)
              (rec (read-char in))]
             [(#\/)
              (let1 c (read-char in)
                (if (eof-object? c)
                    (display "Div" out)
                    (display (char-upcase c) out)))
                (rec (read-char in))]
             [(#\*)
              (display "Mul" out)
              (rec (read-char in))]
             [(#\-)
              (let1 c  (read-char in)
                (if (eof-object? c)
                    (display "Sub" out)
                    (if (char=? #\> c)
                        (display "To" out)
                        (display (char-upcase c) out))))
              (rec (read-char in))]
             [else
              (display c out)
              (rec (read-char in))])]))
       (rec (read-char in))))]))


(define (read-all/port p)
  (let ((r (read p)))
    (if (eof-object? r)
      '()
      (cons r (read-all/port p)))))

(define (read-all fn)
  (call-with-input-file fn read-all/port))
(define (load-file fn)
  (load-list (read-all fn)))

(define (load-list l)
  (for-each (lambda (e) (eval e (interaction-environment))) l))

(define (retrieve-free-vars-decl infile)
  ; FIXME: we cannot use psyntax's load here
  ; FIXME: free-vars-decl.scm lacks import clause
  (load-file infile) 
  (eval '*free-vars-decl* (interaction-environment)))

(define (convert infile)
  (display "// Do not edit this file generated by gen-cproc.scm")
  (newline)
  (let1 procs (map symbol->string (retrieve-free-vars-decl infile))
    (format #t "static const int cProcNum = ~d;\n" (length procs))
    (display "static Object (*cProcFunctions[])(VM* vm, int, const Object*) = {\n")
    (for-each (lambda (proc) (format #t "     ~a,\n" (proc-name->c-proc-name proc))) (reverse procs))
    (display "};\n")
;    (display "#ifdef ENABLE_PROFILER\n")
    (display "static const ucs4char* cProcNames[] = {\n")
    (for-each (lambda (proc) (format #t "     UC(~s),\n" proc)) (reverse procs))
    (display "};\n")
;    (display "#endif\n")
    0))

(let* ((names (cdr (command-line)))
       (infile (car names))
       (outfile (cadr names)))
  (when (file-exists? outfile) (delete-file outfile))
  (with-output-to-file
    outfile
    (lambda () (convert infile))))
